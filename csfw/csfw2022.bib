@inproceedings{DBLP:conf/csfw/ParadzikD22,
	author = {Petar Paradzik and
                  Ante Derek},
	title = {Conditional Observational Equivalence and Off-line Guessing Attacks
                  in Multiset Rewriting},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919659},
	doi = {10.1109/CSF54842.2022.9919659},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/ParadzikD22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We propose conditional observational equivalence — a variant of observational equivalence that is more flexible since it can be made dependent on arbitrary safety trace properties. We extend an existing method for verifying observational equivalence in the multiset rewriting setting with the ability to handle conditions. Our extension can automatically verify conditional observational equivalence for a simple class of conditions that depend only on the structure of the execution. By using conditional observational equivalence, we give the first method for verifying off-line guessing resistance in the multiset rewriting setting and apply it to analyze and verify the properties of EAP-EKE, a password-authenticated key exchange (PAKE) protocol.'}
}


@inproceedings{DBLP:conf/csfw/PonsHMTT22,
	author = {Reynaldo Gil Pons and
                  Ross Horne and
                  Sjouke Mauw and
                  Alwen Tiu and
                  Rolando Trujillo{-}Rasua},
	title = {Is Eve nearby? Analysing protocols under the distant-attacker assumption},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {17--32},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919655},
	doi = {10.1109/CSF54842.2022.9919655},
	timestamp = {Fri, 11 Nov 2022 16:53:15 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/PonsHMTT22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Various modern protocols tailored to emerging wire-less networks, such as body area networks, rely on the proximity and honesty of devices within the network to achieve their security goals. However, there does not exist a security framework that supports the formal analysis of such protocols, leaving the door open to unexpected flaws. In this article we introduce such a security framework, show how it can be implemented in the protocol verification tool Tamarin, and use it to find previously unknown vulnerabilities on two recent key exchange protocols.'}
}


@inproceedings{DBLP:conf/csfw/CortierDD22,
	author = {V{\'{e}}ronique Cortier and
                  Antoine Dallon and
                  St{\'{e}}phanie Delaune},
	title = {A small bound on the number of sessions for security protocols},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {33--48},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919670},
	doi = {10.1109/CSF54842.2022.9919670},
	timestamp = {Fri, 11 Nov 2022 16:53:15 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/CortierDD22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Bounding the number of sessions is a long-standing problem in the context of security protocols. It is well known that even simple properties like secrecy are undecidable when an unbounded number of sessions is considered. Yet, attacks on existing protocols only require a few sessions. In this paper, we propose a sound algorithm that computes a sufficient set of scenarios that need to be considered to detect an attack. Our approach can be applied for both reachability and equivalence properties, for protocols with standard primitives that are type-compliant (unifiable messages have the same type). Moreover, when equivalence properties are considered, else branches are disallowed, and protocols are supposed to be simple (an attacker knows from which role and session a message comes from). Since this class remains undecidable, our algorithm may return an infinite set. However, our experiments show that on most basic protocols of the literature, our algorithm computes a small number of sessions (a dozen). As a consequence, tools for a bounded number of sessions like DeepSec can then be used to conclude that a protocol is secure for an unbounded number of sessions.'}
}


@inproceedings{DBLP:conf/csfw/LiLPLHH22,
	author = {Liyi Li and
                  Yiyun Liu and
                  Deena L. Postol and
                  Leonidas Lampropoulos and
                  David Van Horn and
                  Michael Hicks},
	title = {A Formal Model of Checked {C}},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {49--63},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919657},
	doi = {10.1109/CSF54842.2022.9919657},
	timestamp = {Fri, 18 Aug 2023 09:38:11 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/LiLPLHH22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"We present a formal model of Checked C, a dialect of C that aims to enforce spatial memory safety. Our model pays particular attention to the semantics of dynamically sized, potentially null-terminated arrays. We formalize this model in Coq, and prove that any spatial memory safety errors can be blamed on portions of the program labeled unchecked; this is a Checked C feature that supports incremental porting and backward compatibility. While our model's operational semantics uses annotated (“fat”) pointers to enforce spatial safety, we show that such annotations can be safely erased. Using PLT Redex we formalize an executable version of our model and a compilation procedure to an untyped C-like language, as well as use randomized testing to validate that generated code faithfully simulates the original. Finally, we develop a custom random generator for well-typed and almost-well-typed terms in our Redex model, and use it to search for inconsistencies between our model and the Clang Checked C implementation. We find these steps to be a useful way to co-develop a language (Checked C is still in development) and a core model of it."}
}


@inproceedings{DBLP:conf/csfw/El-KorashyBTDGH22,
	author = {Akram El{-}Korashy and
                  Roberto Blanco and
                  J{\'{e}}r{\'{e}}my Thibault and
                  Adrien Durier and
                  Deepak Garg and
                  Catalin Hritcu},
	title = {SecurePtrs: Proving Secure Compilation with Data-Flow Back-Translation
                  and Turn-Taking Simulation},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {64--79},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919680},
	doi = {10.1109/CSF54842.2022.9919680},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/El-KorashyBTDGH22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Proving secure compilation of partial programs typically requires back-translating an attack against the compiled program to an attack against the source program. To prove back-translation, one can syntactically translate the target attacker to a source one-i.e., syntax-directed back-translation-or show that the interaction traces of the target attacker can also be emitted by source attackers—i.e., trace-directed back-translation. Syntax-directed back-translation is not suitable when the target attacker may use unstructured control flow that the source language cannot directly represent. Trace-directed back-translation works with such syntactic dissimilarity because only the external interactions of the target attacker have to be mimicked in the source, not its internal control flow. Revealing only external interactions is, however, inconvenient when sharing memory via unforgeable pointers, since information about shared pointers stashed in private memory is not present on the trace. This made prior proofs unnecessarily complex, since the generated attacker had to instead stash all reachable pointers. In this work, we introduce more informative data-flow traces, combining the best of syntax- and trace-directed back-translation in a simpler technique that handles both syntactic dissimilarity and memory sharing well, and that is proved correct in Coq. Additionally, we develop a novel turn-taking simulation relation and use it to prove a recomposition lemma, which is key to reusing compiler correctness in such secure compilation proofs. We are the first to mechanize such a recomposition lemma in the presence of memory sharing. We use these two innovations in a secure compilation proof for a code generation compiler pass between a source language with structured control flow and a target language with unstructured control flow, both with safe pointers and components.'}
}


@inproceedings{DBLP:conf/csfw/StrydonckGGTTPB22,
	author = {Thomas Van Strydonck and
                  A{\"{\i}}na Linn Georges and
                  Arma{\"{e}}l Gu{\'{e}}neau and
                  Alix Trieu and
                  Amin Timany and
                  Frank Piessens and
                  Lars Birkedal and
                  Dominique Devriese},
	title = {Proving full-system security properties under multiple attacker models
                  on capability machines},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {80--95},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919645},
	doi = {10.1109/CSF54842.2022.9919645},
	timestamp = {Tue, 21 Mar 2023 21:02:09 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/StrydonckGGTTPB22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Assembly-level protection mechanisms (virtual mem-ory, trusted execution environments, virtualization) make it possible to guarantee security properties of a full system in the presence of arbitrary attacker provided code. However, they typically only support a single trust boundary: code is either trusted or untrusted, and protection cannot be nested. Capability machines provide protection mechanisms that are more fine-grained and that do support arbitrary nesting of protection. We show in this paper how this enables the formal verification of full-system security properties under multiple attacker models: differ-ent security objectives of the full system can be verified under a different choice of trust boundary (i.e. under a different attacker model). The verification approach we propose is modular, and is robust: code outside the trust boundary for a given security objective can be arbitrary, unverified attacker-provided code. It is based on the use of universal contracts for untrusted adversarial code: sound, conservative contracts which can be combined with manual verification of trusted components in a compositional program logic. Compositionality of the program logic also allows us to reuse common parts in the analyses for different attacker models. We instantiate the approach concretely by extending an existing capability machine model with support for memory-mapped 1/0 and we obtain full system, machine-verified security properties about external effect traces while limiting the manual verification effort to a small trusted computing base relevant for the specific property under study.'}
}


@inproceedings{DBLP:conf/csfw/PankovaL22,
	author = {Alisa Pankova and
                  Peeter Laud},
	title = {Interpreting Epsilon of Differential Privacy in Terms of Advantage
                  in Guessing or Approximating Sensitive Attributes},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {96--111},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919656},
	doi = {10.1109/CSF54842.2022.9919656},
	timestamp = {Fri, 11 Nov 2022 16:53:15 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/PankovaL22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Differential privacy is a privacy technique with provable guarantees which is typically achieved by introducing noise to statistics before releasing them. The level of privacy is characterized by a certain numeric parameter E > 0, where smaller E means more privacy. However, there is no common agreement on how small E should be, and the actual likelihood of data leakage for the same E may vary for different released statistics and different datasets. In this paper, we show how to relate E to the increase in the probability of attacker's success in guessing something about the private data. The attacker's goal is stated as a Boolean expression over guessing particular categorical and numerical attributes, where numeric attributes can be guessed with some precision. The paper is built upon the definition of d-privacy, which is a gencralization of E-differential privacy."}
}


@inproceedings{DBLP:conf/csfw/KaramiBJ22,
	author = {Farzane Karami and
                  David A. Basin and
                  Einar Broch Johnsen},
	title = {{DPL:} {A} Language for {GDPR} Enforcement},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {112--129},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919687},
	doi = {10.1109/CSF54842.2022.9919687},
	timestamp = {Mon, 26 Jun 2023 20:45:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/KaramiBJ22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"The General Data Protection Regulation (GDPR) regulates the handling of personal data, including that personal data may be collected and stored only with the data subject's consent, that data is used only for the explicit purposes for which it is collected, and that is deleted after the purposes are served. We propose a programming language called DPL (Data Protection Language) with constructs for enforcing these central GDPR requirements and provide the language's runtime operational semantics. DPL is designed so that GDPR violations cannot occur: potential violations instead result in runtime errors. Moreover, DPL provides constructs to perform privacy-relevant checks, which enable programmers to avoid these errors. Finally, we formalize DPL in Maude, yielding an environment for program simulation, and verify our claims that DPL programs cannot result in privacy violations."}
}


@inproceedings{DBLP:conf/csfw/GondronMV22,
	author = {S{\'{e}}bastien Gondron and
                  Sebastian M{\"{o}}dersheim and
                  Luca Vigan{\`{o}}},
	title = {Privacy as Reachability},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {130--146},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919668},
	doi = {10.1109/CSF54842.2022.9919668},
	timestamp = {Tue, 21 Mar 2023 21:02:09 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/GondronMV22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We show that privacy can be formalized as a reachability problem. We introduce a transaction-process formalism for distributed systems that can exchange cryptographic messages (in a black-box cryptography model). Our formalism includes privacy variables chosen non-deterministically from finite domains (e.g., candidates in a voting protocol), it can work with long-term mutable states (e.g., a hash-key chain) and allows one to specify consciously released information (e.g., number of votes and the result). We discuss examples, e.g., problems of linkability, and the core of the privacy-preserving proximity tracing system DP-3T.'}
}


@inproceedings{DBLP:conf/csfw/WeghornLSPB22,
	author = {Thilo Weghorn and
                  Si Liu and
                  Christoph Sprenger and
                  Adrian Perrig and
                  David A. Basin},
	title = {N-Tube: Formally Verified Secure Bandwidth Reservation in Path-Aware
                  Internet Architectures},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {147--162},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919646},
	doi = {10.1109/CSF54842.2022.9919646},
	timestamp = {Tue, 07 May 2024 20:11:42 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/WeghornLSPB22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We present N-Tube, a novel, provably secure, inter-domain bandwidth reservation algorithm that runs on a network architecture supporting path-based forwarding. N-Tube reserves global end-to-end bandwidth along network paths in a distributed, neighbor-based, and tube-fair way. It guarantees that benign bandwidth demands are granted available allocations that are immutable, stable, lower-bounded, andfair, even during adversarial demand bursts. We formalize N-Tube and powerful adversaries as a labeled transition system, and inductively prove its safety and security properties. We also apply statistical model checking to validate our proofs and perform an additional quantitative assessment of N-Tube, providing strong guarantees for protection against DDoS attacks. We are not aware of any other complex networked system designs that have been subjected to a comparable analysis of both their qualitative properties (such as correctness and security) and their quantitative properties (such as performance).'}
}


@inproceedings{DBLP:conf/csfw/MondalAA22,
	author = {Priyanka Mondal and
                  Maximilian Algehed and
                  Owen Arden},
	title = {Applying consensus and replication securely with {FLAQR}},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {163--178},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919637},
	doi = {10.1109/CSF54842.2022.9919637},
	timestamp = {Sat, 30 Sep 2023 09:37:59 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/MondalAA22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Availability is crucial to the security of distributed systems, but guaranteeing availability is hard, especially when participants in the system may act maliciously. Quorum replication protocols provide both integrity and availability: data and computation is replicated at multiple independent hosts, and a quorum of these hosts must agree on the output of all operations applied to the data. Unfortunately, these protocols have high overhead and can be difficult to calibrate for a specific application's needs. Ideally, developers could use high-level abstractions for consensus and replication to write fault-tolerant code by that is secure by construction. This paper presents Flow-Limited Authorization for Quorum Replication (FLAQR), a core calculus for building distributed applications with heterogeneous quorum replication protocols while enforcing end-to-end information security. Our type system ensures that well-typed FLAQR programs cannot fail (experience an unrecoverable error) in ways that violate their type-level specifications. We present noninterference theorems that characterize FLAQR's confidentiality, integrity, and availability in the presence of consensus, replication, and failures, as well as a liveness theorem for the class of majority quorum protocols under a bounded number of faults."}
}


@inproceedings{DBLP:conf/csfw/MestelMR22,
	author = {David Mestel and
                  Johannes M{\"{u}}ller and
                  Pascal Reisert},
	title = {How Efficient are Replay Attacks against Vote Privacy? {A} Formal
                  Quantitative Analysis},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {179--194},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9979167},
	doi = {10.1109/CSF54842.2022.9979167},
	timestamp = {Sun, 17 Dec 2023 20:56:29 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/MestelMR22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Replay attacks are among the most well-known attacks against vote privacy. Many e-voting systems have been proven vulnerable to replay attacks, including systems like Helios that are used in real practical elections.Despite their popularity, it is commonly believed that replay attacks are inefficient but the actual threat that they pose to vote privacy has never been studied formally. Therefore, in this paper, we precisely analyze for the first time how efficient replay attacks really are.We study this question from commonly used and complementary perspectives on vote privacy, showing as an independent contribution that a simple extension of a popular game-based privacy definition corresponds to a strong entropy-based notion.Our results demonstrate that replay attacks can be devastating for a voter’s privacy even when an adversary’s resources are very limited. We illustrate our formal findings by applying them to a number of real-world elections, showing that a modest number of replays can result in significant privacy loss. Overall, our work reveals that, contrary to a common belief, replay attacks can be very efficient and must therefore be considered a serious threat.'}
}


@inproceedings{DBLP:conf/csfw/BursucM22,
	author = {Sergiu Bursuc and
                  Sjouke Mauw},
	title = {Contingent payments from two-party signing and verification for abelian
                  groups},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {195--210},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919674},
	doi = {10.1109/CSF54842.2022.9919674},
	timestamp = {Mon, 04 Dec 2023 13:56:31 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/BursucM22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'The fair exchange problem has faced for a long time the bottleneck of a required trusted third party. The recent development of blockchains introduces a new type of party to this problem, whose trustworthiness relies on a public ledger and distributed computation. The challenge in this setting is to reconcile the minimalistic and public nature of blockchains with elaborate fair exchange requirements, from functionality to privacy. Zero-knowledge contingent payments (ZKCP) are a class of protocols that are promising in this direction, allowing the fair exchange of data for payment. We propose a new ZKCP protocol that, when compared to others, requires less computation from the blockchain and less interaction between parties. The protocol is based on two-party (weak) adaptor signatures, which we show how to instantiate from state of the art multiparty signing protocols. We improve the symbolic definition of ZKCP security and, for automated verification with Tamarin, we propose a general security reduction from the theory of abelian groups to the theory of exclusive or.'}
}


@inproceedings{DBLP:conf/csfw/CiampiLZ22,
	author = {Michele Ciampi and
                  Yun Lu and
                  Vassilis Zikas},
	title = {Collusion-Preserving Computation without a Mediator},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {211--226},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919678},
	doi = {10.1109/CSF54842.2022.9919678},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/CiampiLZ22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Collusion-free (CF) and collusion-preserving (CP) protocols enrich the standard security offered by multi-party computation (MPC), to tackle settings where subliminal communication is undesirable. However, all existing solutions make arguably unrealistic assumptions on setups, such as physical presence of the parties, access to physical envelopes, or extreme isolation, where the only means of communication is a star-topology network. The above state of affairs remained a limitation of such protocols, which was even reinforced by impossibility results. Thus, for years, it has been unclear if and how the above setup assumptions could be relaxed towards more realistic scenarios. Motivated also by the increasing interest in using hardware tokens for cryptographic applications, in this work we provide the first solution to collusion preserving computation which uses weaker and more common assumptions than the state of the art, i.e., an authenticated broadcast functionality and access to honestly generated trusted hardware tokens. We prove that our protocol is collusion-preserving (in short, CP) secure as long as no parties abort. In the case of an aborting adversary, our protocol still achieves standard (G)UC security with identifiable (and unanimous) abort. Leveraging the above identifiability property, we augment our protocol with a penalization scheme which ensures that it is not profitable to abort, thereby obtaining CP security against incentive-driven attackers. To define (and prove) this latter result, we combine the Rational Protocol Design (RPD) methodology by Garay et al. [FOCS 2013] with the CP framework of Alwen et al. [CRYPTO 2012] to derive a definition of security in the presence of incentive-driven local adversaries which can be of independent interest. Similar to existing CP/CF solutions, our protocol preserves, as a fallback, security against monolithic adversaries, even when the setup (i.e., the hardware tokens) is compromised or corrupted. In addition, our fallback solution achieves identifiable and unanimous abort, which we prove are impossible in previous CP solutions.'}
}


@inproceedings{DBLP:conf/csfw/DupressoirKO22,
	author = {Fran{\c{c}}ois Dupressoir and
                  Konrad Kohbrok and
                  Sabine Oechsner},
	title = {Bringing State-Separating Proofs to EasyCrypt {A} Security Proof for
                  Cryptobox},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {227--242},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919671},
	doi = {10.1109/CSF54842.2022.9919671},
	timestamp = {Tue, 21 Mar 2023 21:02:09 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/DupressoirKO22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Machine-checked cryptography aims to reinforce confidence in the primitives and protocols that underpin all digital security. However, machine-checked proof techniques remain in practice difficult to apply to real-world constructions. A particular challenge is structured reasoning about complex constructions at different levels of abstraction. The State-Separating Proofs (SSP) methodology for guiding cryptographic proofs by Brzuska, Delignat-Lavaud, Fournet, Kohbrok and Kohlweiss (ASIACRYPT'18) is a promising contestant to support such reasoning. In this work, we explore how SSPs can guide EasyCrypt formalisations of proofs for modular constructions. Concretely, we propose a mapping from SSP to EasyCrypt concepts which enables us to enhance cryptographic proofs with SSP insights while maintaining compatibility with existing EasyCrypt proof support. To showcase our insights, we develop a formal security proof for the cryptobox family of public-key authenticated encryption schemes based on non-interactive key exchange and symmetric authenticated encryption. As a side effect, we obtain the first formal security proof for NaCl's instantiation of cryptobox. Finally we discuss changes to the practice of SSP on paper and potential implications for future tool designers."}
}


@inproceedings{DBLP:conf/csfw/CeragioliGDB22,
	author = {Lorenzo Ceragioli and
                  Letterio Galletta and
                  Pierpaolo Degano and
                  David A. Basin},
	title = {{IFCIL:} An Information Flow Configuration Language for SELinux},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {243--259},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919690},
	doi = {10.1109/CSF54842.2022.9919690},
	timestamp = {Mon, 26 Jun 2023 20:45:22 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/CeragioliGDB22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Security Enhanced Linux (SELinux) is a security architecture for Linux implementing mandatory access control. It has been used in numerous security-critical contexts ranging from servers to mobile devices. But this is challenging as SELinux security policies are difficult to write, understand, and maintain. Recently, the intermediate language CIL was introduced to foster the development of high-level policy languages and to write structured configurations. However, CIL lacks mechanisms for ensuring that the resulting configurations obey desired information flow policies. To remedy this, we propose IFCIL, a backward compatible extension of CIL for specifying fine-grained information flow requirements for CIL configurations. Using IFCIL, administrators can express, e.g., confidentiality, integrity, and non-interference properties. We also provide a tool to statically verify these requirements.'}
}


@inproceedings{DBLP:conf/csfw/LiZ22,
	author = {Peixuan Li and
                  Danfeng Zhang},
	title = {Towards a General-Purpose Dynamic Information Flow Policy},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {260--275},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919639},
	doi = {10.1109/CSF54842.2022.9919639},
	timestamp = {Sun, 17 Dec 2023 20:56:29 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/LiZ22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Noninterference offers a rigorous end-to-end guarantee for secure propagation of information. However, real-world systems almost always involve security requirements that change during program execution, making noninterference inapplicable. Prior works alleviate the limitation to some extent, but even for a veteran in information flow security, understanding the subtleties in the syntax and semantics of each policy is challenging, largely due to very different policy specification languages, and more fundamentally, semantic requirements of each policy. We take a top-down approach and present a novel information flow policy, called Dynamic Release, which allows information flow restrictions to downgrade and upgrade in arbitrary ways. Dynamic Release is formalized on a novel framework that, for the first time, allows us to compare and contrast various dynamic policies in the literature. We show that Dynamic Release generalizes declassification, erasure, delegation and revocation. Moreover, it is the only dynamic policy that is both applicable and correct on a benchmark of tests with dynamic policy.'}
}


@inproceedings{DBLP:conf/csfw/Mestel22,
	author = {David Mestel},
	title = {Beware of Greeks bearing entanglement? Quantum covert channels, information
                  flow and non-local games},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {276--288},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919683},
	doi = {10.1109/CSF54842.2022.9919683},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/Mestel22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Can quantum entanglement increase the capacity of (classical) covert channels? To one familiar with Holevo's Theorem it is tempting to think that the answer is obviously no. However, in this work we show: quantum entanglement can in fact increase the capacity of a classical covert channel, in the presence of an active adversary; on the other hand, a zero-capacity channel is not improved by entanglement, so entanglement cannot create ‘purely quantum’ covert channels; the problem of determining the capacity of a given channel in the presence of entanglement is undecidable; but there is an algorithm to bound the entangled capacity of a channel from above, adapted from the semi-definite hierarchy from the theory of non-local games, whose close connection to channel capacity is at the core of all of our results."}
}


@inproceedings{DBLP:conf/csfw/BaeldeDKM22,
	author = {David Baelde and
                  St{\'{e}}phanie Delaune and
                  Adrien Koutsos and
                  Sol{\`{e}}ne Moreau},
	title = {Cracking the Stateful Nut: Computational Proofs of Stateful Security
                  Protocols using the Squirrel Proof Assistant},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {289--304},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919665},
	doi = {10.1109/CSF54842.2022.9919665},
	timestamp = {Sat, 30 Sep 2023 09:37:58 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BaeldeDKM22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Bana and Comon have proposed a logical approach to proving protocols in the computational model, which they call the Computationally Complete Symbolic Attacker (CCSA). The proof assistant Squirrel implements a verification technique that elaborates on this approach, building on a meta-logic over the CCSA base logic. In this paper, we show that this meta-logic can naturally be extended to handle protocols with mutable states (key updates, counters, etc.) and we extend Squirrel'S proof system to be able to express the complex proof arguments that are sometimes required for these protocols. Our theoretical contributions have been implemented in Squirrel and validated on a number of case studies, including a proof of the YubiKey and YubiHSM protocols."}
}


@inproceedings{DBLP:conf/csfw/BoeiraA22,
	author = {Felipe Boeira and
                  Mikael Asplund},
	title = {Exploiting Partial Order of Keys to Verify Security of a Vehicular
                  Group Protocol},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {305--318},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919664},
	doi = {10.1109/CSF54842.2022.9919664},
	timestamp = {Mon, 26 Jun 2023 20:45:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BoeiraA22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Vehicular networks will enable a range of novel applications to enhance road traffic efficiency, safety, and reduce fuel consumption. As for other cyber-physical systems, security is essential to the deployment of these applications and standardisation efforts are ongoing. In this paper, we perform a systematic security evaluation of a vehicular platooning protocol through a thorough analysis of the protocol and security standards. We tackle the complexity of the resulting model with a proof strategy based on a relation on keys. The key relation forms a partial order, which encapsulates both secrecy and authenticity dependencies. We show that our order-aware approach makes the verification feasible and proves authenticity properties along with secrecy of all keys used throughout the protocol.'}
}


@inproceedings{DBLP:conf/csfw/ChevalCK22,
	author = {Vincent Cheval and
                  Rapha{\"{e}}lle Crubill{\'{e}} and
                  Steve Kremer},
	title = {Symbolic protocol verification with dice: process equivalences in
                  the presence of probabilities},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {319--334},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919644},
	doi = {10.1109/CSF54842.2022.9919644},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/ChevalCK22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Symbolic protocol verification generally abstracts probabilities away, considering computations that succeed only with negligible probability, such as guessing random numbers or breaking an encryption scheme, as impossible. This abstraction, sometimes referred to as the perfect cryptography assumption, has shown very useful as it simplifies automation of the analysis. However, probabilities may also appear in the control flow where they are generally not negligible. In this paper we consider a framework for symbolic protocol analysis with a probabilistic choice operator: the probabilistic applied pi calculus. We define and explore the relationships between several behavioral equivalences. In particular we show the need for randomized schedulers and exhibit a counter-example to a result in a previous work that relied on non-randomized ones. As in other frameworks that mix both non-deterministic and probabilistic choices, schedulers may sometimes be unrealistically powerful. We therefore consider two subclasses of processes that avoid this problem. In particular, when considering purely non-deterministic protocols, as is done in classical symbolic verification, we show that a probabilistic adversary has-maybe surprisingly-a strictly superior distinguishing power for may testing, which, when the number of sessions is bounded, we show to coincide with purely possibilistic similarity.'}
}


@inproceedings{DBLP:conf/csfw/DraganDEGHRRS22,
	author = {Constantin Catalin Dragan and
                  Fran{\c{c}}ois Dupressoir and
                  Ehsan Estaji and
                  Kristian Gj{\o}steen and
                  Thomas Haines and
                  Peter Y. A. Ryan and
                  Peter B. R{\o}nne and
                  Morten Rotvold Solberg},
	title = {Machine-Checked Proofs of Privacy Against Malicious Boards for Selene
                  {\&} Co},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {335--347},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919663},
	doi = {10.1109/CSF54842.2022.9919663},
	timestamp = {Sun, 13 Nov 2022 17:52:18 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/DraganDEGHRRS22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Privacy is a notoriously difficult property to achieve in complicated systems and especially in electronic voting schemes. Moreover, electronic voting schemes is a class of systems that require very high assurance. The literature contains a number of ballot privacy definitions along with security proofs for common systems. Some machine-checked security proofs have also appeared. We define a new ballot privacy notion that captures a larger class of voting schemes. This notion improves on the state of the art by taking into account that verification in many schemes will happen or must happen after the tally has been published, not before as in previous definitions. As a case study we give a machine-checked proof of privacy for Selene, which is a remote electronic voting scheme which offers an attractive mix of security properties and usability. Prior to our work, the computational privacy of Selene has never been formally verified. Finally, we also prove that MiniVoting and Belenios satisfies our definition.'}
}


@inproceedings{DBLP:conf/csfw/FernandesMPD22,
	author = {Natasha Fernandes and
                  Annabelle McIver and
                  Catuscia Palamidessi and
                  Ming Ding},
	title = {Universal Optimality and Robust Utility Bounds for Metric Differential
                  Privacy},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {348--363},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919647},
	doi = {10.1109/CSF54842.2022.9919647},
	timestamp = {Wed, 08 Nov 2023 07:52:02 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/FernandesMPD22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"We study the privacy-utility trade-off in the context of metric differential privacy. Ghosh et al. introduced the idea of universal optimality to characterise the “best” mechanism for a certain query that simultaneously satisfies (a fixed) $\\mathcal{E-}$ differential privacy constraint whilst at the same time providing better utility compared to any other s-differentially private mechanism for the same query. They showed that the Geometric mechanism is universally optimal for the class of counting queries. On the other hand, Brenner and Nissim showed that outside the space of counting queries, and for the Bayes risk loss function, no such universally optimal mechanisms exist. Except for universal optimality of the Laplace mechanism, there have been no generalisations of these universally optimal results to other classes of differentially-private mechanisms. In this paper we use metric differential privacy and quantitative information flow as the fundamental principle for studying universal optimality. Metric differential privacy is a generali-sation of both standard (i.e., central) differential privacy and local differential privacy, and it is increasingly being used in various application domains, for instance in location privacy and in privacy preserving machine learning. As do Ghosh et al. and Brenner and Nissim, we measure utility in terms of loss functions, and we interpret the notion of a privacy mechanism as an information-theoretic channel satisfying constraints defined by ε-differcntlal privacy and a metric meaningful to the underlying state space. Using this framework we are able to clarify Nissim and Brenner's negative results by (a) that in fact all privacy types contain optimal mechanisms relative to certain kinds of non-trivial loss functions, and (b) extending and generalising their negative results beyond Bayes risk specifically to a wide class of non-trivial loss functions. Our exploration suggests that universally optimal mechanisms are indeed rare within privacy types. We therefore propose weaker universal benchmarks of utility called privacy type ca-pacities. We show that such capacities always exist and can be computed using a convex optimisation algorithm. We illustrate these ideas on a selection of examples with several different underlying metrics."}
}


@inproceedings{DBLP:conf/csfw/HorneMY22,
	author = {Ross Horne and
                  Sjouke Mauw and
                  Semen Yurkov},
	title = {Unlinkability of an Improved Key Agreement Protocol for {EMV} 2nd
                  Gen Payments},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {364--379},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919666},
	doi = {10.1109/CSF54842.2022.9919666},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/HorneMY22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'To address known privacy problems with the EMV standard, EMVCo have proposed a Blinded Diffie-Hellman key establishment protocol, which is intended to be part of a future 2nd Gen EMV protocol. We point out that active attackers were not previously accounted for in the privacy requirements of this proposal protocol, and demonstrate that an active attacker can compromise unlinkability within a distance of 100cm. Here, we adopt a strong definition of unlinkability that does account for active attackers and propose an enhancement of the protocol proposed by EMVCo. We prove that our protocol does satisfy strong unlinkability, while preserving authentication.'}
}


@inproceedings{DBLP:conf/csfw/OakleyOT22,
	author = {Lisa Oakley and
                  Alina Oprea and
                  Stavros Tripakis},
	title = {Adversarial Robustness Verification and Attack Synthesis in Stochastic
                  Systems},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {380--395},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919660},
	doi = {10.1109/CSF54842.2022.9919660},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/OakleyOT22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Probabilistic model checking is a useful technique for specifying and verifying properties of stochastic systems including randomized protocols and reinforcement learning models. However, these methods rely on the assumed structure and probabilities of certain system transitions. These assumptions may be incorrect, and may even be violated by an adversary who gains control of some system components. In this paper, we develop a formal framework for adversarial robustness in systems modeled as discrete time Markov chains (DTMCs). We base our framework on existing methods for verifying probabilistic temporal logic properties and extend it to include deterministic, memoryless policies acting in Markov decision processes (MDPs). Our framework includes a flexible approach for specifying structure-preserving and non structure-preserving adversarial models. We outline a class of threat models under which adversaries can perturb system transitions, constrained by an\nε\nball around the original transition probabilities. We define three main DTMC adversarial robustness problems: adversarial robustness verification, maximal\nδ\nsynthesis, and worst case attack synthesis. We present two optimization-based solutions to these three problems, leveraging traditional and parametric probabilistic model checking techniques. We then evaluate our solutions on two stochastic protocols and a collection of Grid World case studies, which model an agent acting in an environment described as an MDP. We find that the parametric solution results in fast computation for small parameter spaces. In the case of less restrictive (stronger) adversaries, the number of parameters increases, and directly computing property satisfaction probabilities is more scalable. We demonstrate the usefulness of our definitions and solutions by comparing system outcomes over various properties, threat models, and case studies.'}
}


@inproceedings{DBLP:conf/csfw/BunGG22,
	author = {Mark Bun and
                  Marco Gaboardi and
                  Ludmila Glinskih},
	title = {The Complexity of Verifying Boolean Programs as Differentially Private},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {396--411},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919653},
	doi = {10.1109/CSF54842.2022.9919653},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/BunGG22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We study the complexity of the problem of verifying differential privacy for while-like programs working over boolean values and making probabilistic choices. Programs in this class can be interpreted into finite-state discrete-time Markov Chains (DTMC). We show that the problem of deciding whether a program is differentially private for specific values of the privacy parameters is PSPACE-complete. To show that this problem is in PSPACE, we adapt classical results about computing hitting probabilities for DTMC. To show PSPACE-hardness we use a reduction from the problem of checking whether a program almost surely terminates or not. We also show that the problem of approximating the privacy parameters that a program provides is PSPACE-hard. Moreover, we investigate the complexity of similar problems also for several relaxations of differential privacy: Renyi differential privacy, concentrated differential privacy, and truncated concentrated differential privacy. For these notions, we consider gap-versions of the problem of deciding whether a program is private or not and we show that all of them are PSPACE-complete.'}
}


@inproceedings{DBLP:conf/csfw/BrajeLWKPKCC22,
	author = {Timothy M. Braje and
                  Alice R. Lee and
                  Andrew Wagner and
                  Benjamin Kaiser and
                  Daniel Park and
                  Martine Kalke and
                  Robert K. Cunningham and
                  Adam Chlipala},
	title = {Adversary Safety by Construction in a Language of Cryptographic Protocols},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {412--427},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919638},
	doi = {10.1109/CSF54842.2022.9919638},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/BrajeLWKPKCC22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Compared to ordinary concurrent and distributed systems, cryptographic protocols are distinguished by the need to reason about interference by adversaries. We suggest a new layered approach to tame that complexity, via an executable protocol language whose semantics does not reveal an adversary directly, instead enforcing a set of intuitive hygiene rules. By virtue of those rules, protocols written in this language provably behave identically with or without interference by active Dolev-Yao-style adversaries. As a result, formal reasoning about protocols can be simplified enough that even naïve model checking can establish correctness of a multiparty protocol, through analysis of a state space with no adversary. We present the design and implementation of SPICY, short for Secure Protocols Implemented CorrectlY, including the semantics of its input languages; the essential safety proofs, formalized in the Coq theorem prover; and the automation techniques. We provide a preliminary evaluation of the tool's performance and capabilities via a handful of case studies."}
}


@inproceedings{DBLP:conf/csfw/MayZ22,
	author = {Alexander May and
                  Floyd Zweydinger},
	title = {Legendre {PRF} (Multiple) Key Attacks and the Power of Preprocessing},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {428--438},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919640},
	doi = {10.1109/CSF54842.2022.9919640},
	timestamp = {Mon, 14 Nov 2022 08:50:25 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/MayZ22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {"Due to its amazing speed and multiplicative properties the Legendre PRF recently finds widespread applications e.g. in Ethereum 2.0, multiparty computation and in the quantum-secure signature proposal LegRoast. However, its security is not yet extensively studied. The Legendre PRF computes for a key $k$ on input $x$ the Legendre symbol $L_{k}(x)=(\\frac{x+k}{p})$ in some finite field $\\mathbb{F}_{p}$ . As standard notion, PRF security is analysed by giving an attacker oracle access to $L_{k}(\\cdot)$ . Khovratovich's collision-based algorithm recovers $k$ using $L_{k}(\\cdot)$ in time $\\sqrt{p}$ with constant memory. It is a major open problem whether this birthday-bound complexity can be beaten. We show a somewhat surprising wide-ranging analogy between the discrete logarithm problem and Legendre symbol computations. This analogy allows us to adapt various algorithmic ideas from the discrete logarithm setting. More precisely, we present a small memory multiple-key attack on $m$ Legendre keys $k_{1}, \\ldots, k_{m}$ in time $\\sqrt{mp}$ , i.e. with amortized cost $\\sqrt{p/m}$ per key. This multiple-key attack might be of interest in the Ethereum context, since recovering many keys simultaneously maximizes an attacker's profit. Moreover, we show that the Legendre PRF admits precomputation attacks, where the precomputation depends on the public $p$ only - and not on a key $k$ . Namely, an attacker may compute e.g. in precomputation time $p^{\\frac{2}{3}}$ a hint of size $p^{\\frac{1}{3}}$ . On receiving access to $L_{k}(\\cdot)$ in an online phase, the attacker then uses the hint to recover the desired key $k$ in time only $p^{\\frac{1}{3}}$ . Thus, the attacker's online complexity again beats the birthday-bound. In addition, our precomputation attack can also be combined with our multiple-key attack. We explicitly give various tradeoffs between precomputation and online phase. E.g. for attacking $m$ keys one may spend time $mp^{\\frac{2}{3}}$ in the precomputation phase for constructing a hint of size $m^{2}p^{\\frac{1}{3}}$ . In an online phase, one then finds all $m$ keys in total time only $p^{\\frac{1}{3}}$ . Precomputation attacks might again be interesting in the Ethereum 2.0 context, where keys are frequently changed such that a heavy key-independent precomputation pays off."}
}


@inproceedings{DBLP:conf/csfw/HollenbergRR22,
	author = {Tommy Hollenberg and
                  Mike Rosulek and
                  Lawrence Roy},
	title = {A Complete Characterization of Security for Linicrypt Block Cipher
                  Modes},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {439--454},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919676},
	doi = {10.1109/CSF54842.2022.9919676},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/HollenbergRR22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We give characterizations of IND\nMisplaced &\n-CPA security. Our characterization is linear-algebraic in nature and is easy to check for a candidate mode. Interestingly, we prove that a Linicrypt block cipher mode is secure if and only if it is secure against adversaries who choose all-zeroes plaintexts.'}
}


@inproceedings{DBLP:conf/csfw/MassadJSRGT22,
	author = {Mohamed El Massad and
                  Nahid Juma and
                  Jonathan Shahen and
                  Mariana Raykova and
                  Siddharth Garg and
                  Mahesh Tripunitara},
	title = {Locked Circuit Indistinguishability: {A} Notion of Security for Logic
                  Locking},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {455--470},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919691},
	doi = {10.1109/CSF54842.2022.9919691},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/MassadJSRGT22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'We address logic locking, a mechanism for securing digital Integrated Circuits (ICs) from piracy by untrustworthy foundries. We discuss previous work and the state-of-the-art, and observe that, despite more than a decade of research that has gone into the topic (resulting in both powerful attacks and subsequent defenses), there is no consensus on what it means for a particular locking mechanism to be secure. This paper attempts to remedy this situation. Specifically, it formulates a definition of security for a logic locking mechanism based on indistinguishability and relates the definition to security from actual attackers in a precise and unambiguous manner. We then describe a mechanism that satisfies the definition, thereby achieving (provable) security from all prior attacks. The mechanism assumes the existence of both a puncturable pseudorandom function family and an indistinguishability obfuscator, two cryptographic primitives that exist under well-founded assumptions. The mechanism builds upon the Stripped-Functionality Logic Locking (SFLL) framework, a state-of-the-art family of locking mechanisms whose potential for ever achieving security is currently in question. Along the way, partly as motivation, we present additional results, such as a reason founded in average-case complexity for why benchmark circuits locked with a prior scheme are susceptible to the well-known SAT attack against such schemes, and why provably thwarting the SAT attack is insufficient as a meaningful notion of security for logic locking.'}
}


@inproceedings{DBLP:conf/csfw/BeutnerF22,
	author = {Raven Beutner and
                  Bernd Finkbeiner},
	title = {Prophecy Variables for Hyperproperty Verification},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {471--485},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919658},
	doi = {10.1109/CSF54842.2022.9919658},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/BeutnerF22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'Temporal logics for hyperproperties like HyperLTL use trace quantifiers to express properties that relate multiple system runs. In practice, the verification of such specifications is mostly limited to formulas without quantifier alternation, where verification can be reduced to checking a trace property over the self-composition of the system. Quantifier alternations like\n∀π.∃\nπ\n′\n.ϕ\n, can either be solved by complementation or with an interpretation as a two-person game between a v-player, who incrementally constructs the trace, and an 3-player, who constructs. The game-based approach is significantly cheaper but incomplete because the 3-player does not know the future moves of the\nω\n-player. In this paper, we establish that the game-based approach can be made complete by adding (w-regular) temporal prophecies. Our proof is constructiphecies.'}
}


@inproceedings{DBLP:conf/csfw/HsuBKT22,
	author = {Tzu{-}Han Hsu and
                  Borzoo Bonakdarpour and
                  Eunsuk Kang and
                  Stavros Tripakis},
	title = {Mapping Synthesis for Hyperproperties},
	booktitle = {35th {IEEE} Computer Security Foundations Symposium, {CSF} 2022, Haifa,
                  Israel, August 7-10, 2022},
	pages = {486--500},
	publisher = {{IEEE}},
	year = {2022},
	url = {https://doi.org/10.1109/CSF54842.2022.9919679},
	doi = {10.1109/CSF54842.2022.9919679},
	timestamp = {Fri, 11 Nov 2022 16:53:14 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/HsuBKT22.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {'In system design, high-level system models typically need to be mapped to an execution platform (e.g., hardware, environment, compiler, etc). The platform may naturally strengthen some constraints or weaken some others, but it is expected that the low-level implementation on the platform should preserve all the functional and extra-functional properties of the model, including the ones for information-flow security. It is, however, well known that simple notions of refinement do not preserve information-flow security properties. In this paper, we propose a novel automated mapping synthesis approach that preserves hyperproperties expressed in the temporal logic HyperLTL. The significance of our technique is that it can handle formulas with quantifier alternations, which is typically the source of difficulty in refinement for information-flow security policies. We reduce the mapping synthesis problem to HyperLTL model checking and leverage recent efforts in bounded model checking for hyperproperties. We demonstrate how mapping synthesis can be used in various applications, including enforcing non-interference and automating secrecy-preserving refinement mapping. We also evaluate our approach using the battleship game and password validation use cases.'}
}
