@inproceedings{DBLP:conf/csfw/LouniciNEOT21,
	author = {Sofiane Lounici and
                  Mohamed Njeh and
                  Orhan Ermis and
                  Melek {\"{O}}nen and
                  Slim Trabelsi},
	title = {Yes We can: Watermarking Machine Learning Models beyond Classification},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--14},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00044},
	doi = {10.1109/CSF51468.2021.00044},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/LouniciNEOT21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Since machine learning models have become a valuable asset for companies, watermarking techniques have been developed to protect the intellectual property of these models and prevent model theft. We observe that current watermarking frameworks solely target image classification tasks, neglecting a considerable part of machine learning techniques. In this paper, we propose to address this lack and study the watermarking process of various machine learning techniques such as machine translation, regression, binary image classification and reinforcement learning models. We adapt current definitions to each specific technique and we evaluate the main characteristics of the watermarking process, in particular the robustness of the models against a rational adversary. We show that watermarking models beyond classification is possible while preserving their overall performance. We further investigate various attacks and discuss the importance of the performance metric in the verification process and its impact on the success of the adversary.}
}


@inproceedings{DBLP:conf/csfw/LanotteMMT21,
	author = {Ruggero Lanotte and
                  Massimo Merro and
                  Andrei Munteanu and
                  Simone Tini},
	title = {Formal Impact Metrics for Cyber-physical Attacks},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00040},
	doi = {10.1109/CSF51468.2021.00040},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/LanotteMMT21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Cyber-Physical systems (CPSs) are exposed to cyber- physical attacks, i.e., security breaches in cyberspace that adversely affect the physical processes of the systems.We define two probabilistic metrics to estimate the physical impact of attacks targeting cyber-physical systems formalised in terms of a probabilistic hybrid extension of Hennessy and Regan’s Timed Process Language. Our impact metrics estimate the impact of cyber-physical attacks taking into account: (i) the severity of the inflicted damage in a given amount of time, and (ii) the probability that these attacks are actually accomplished, according to the dynamics of the system under attack. In doing so, we pay special attention to stealthy attacks, i. e., attacks that cannot be detected by intrusion detection systems. As further contribution, we show that, under precise conditions, our metrics allow us to estimate the impact of attacks targeting a complex CPS in a compositional way, i.e., in terms of the impact on its sub-systems.}
}


@inproceedings{DBLP:conf/csfw/KerberKK21,
	author = {Thomas Kerber and
                  Aggelos Kiayias and
                  Markulf Kohlweiss},
	title = {{KACHINA} - Foundations of Private Smart Contracts},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00002},
	doi = {10.1109/CSF51468.2021.00002},
	timestamp = {Sat, 30 Sep 2023 09:37:59 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/KerberKK21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Smart contracts present a uniform approach for deploying distributed computation and have become a popular means to develop security critical applications. A major barrier to adoption for many applications is the public nature of existing systems, such as Ethereum. Several systems satisfying various definitions of privacy and requiring various trust assumptions have been proposed; however, none achieved the universality and uniformity that Ethereum achieved for non-private contracts: One unified method to construct most contracts. We provide a unified security model for private smart contracts which is based on the Universal Composition (UC) model and propose a novel core protocol, KACHINA, for deploying privacy-preserving smart contracts, which encompasses previous systems. We demonstrate the KACHINA method of smart contract development, using it to construct a contract that implements privacy-preserving payments, along the lines of Zerocash, which is provably secure in the UC setting and facilitates concurrency.}
}


@inproceedings{DBLP:conf/csfw/DupressoirZ21,
	author = {Fran{\c{c}}ois Dupressoir and
                  Sara Zain},
	title = {Machine-Checking Unforgeability Proofs for Signature Schemes with
                  Tight Reductions to the Computational Diffie-Hellman Problem},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00014},
	doi = {10.1109/CSF51468.2021.00014},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/DupressoirZ21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Digital signatures based on the Discrete Logarithm (DL) problem often suffer from long signature sizes, and reductions made loose by the use of Pointcheval and Stern’s Forking Lemma. At EUROCRYPT 2003, Goh and Jarecki provided the first forking-free proof of unforgeability for a DL-based signature scheme—rooting its security in the hardness of the Computational Diffie-Hellman problem in the random oracle model. In this paper, we present and discuss the first machine-checked proofs for DL-based signature schemes reducing tightly to CDH, produced using EasyCrypt. We craft our proofs around a shim which reduces the local proof effort, and helps us identify patterns that can be easily adapted to similar tightly-secure DL-based schemes.}
}


@inproceedings{DBLP:conf/csfw/El-Korashy0PD0P21,
	author = {Akram El{-}Korashy and
                  Stelios Tsampas and
                  Marco Patrignani and
                  Dominique Devriese and
                  Deepak Garg and
                  Frank Piessens},
	title = {CapablePtrs: Securely Compiling Partial Programs Using the Pointers-as-Capabilities
                  Principle},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00036},
	doi = {10.1109/CSF51468.2021.00036},
	timestamp = {Sat, 09 Apr 2022 12:41:22 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/El-Korashy0PD0P21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Capability machines such as CHERI provide memory capabilities that can be used by compilers to provide security benefits for compiled code (e.g., memory safety). The existing C to CHERI compiler, for example, achieves memory safety by following a principle called “pointers as capabilities” (PAC). Informally, PAC says that a compiler should represent a source language pointer as a machine code capability. But the security properties of PAC compilers are not yet well understood. We show that memory safety is only one aspect, and that PAC compilers can provide significant additional security guarantees for partial programs: the compiler can provide security guarantees for a compilation unit, even if that compilation unit is later linked to attacker-provided machine code.As such, this paper is the first to study the security of PAC compilers for partial programs formally. We prove for a model of such a compiler that it is fully abstract. The proof uses a novel proof technique (dubbed TrICL, read trickle), which should be of broad interest because it reuses the whole-program compiler correctness relation for full abstraction, thus saving work. We also implement our scheme for C on CHERI, show that we can compile legacy C code with minimal changes, and show that the performance overhead of compiled code is roughly proportional to the number of cross-compilation-unit function calls.}
}


@inproceedings{DBLP:conf/csfw/BartolettiLZ21,
	author = {Massimo Bartoletti and
                  Stefano Lande and
                  Roberto Zunino},
	title = {Computationally sound Bitcoin tokens},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00022},
	doi = {10.1109/CSF51468.2021.00022},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BartolettiLZ21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {We propose a secure and efficient implementation of fungible tokens on Bitcoin. Our technique is based on a small extension of the Bitcoin script language, which allows the spending conditions in a transaction to depend on the neighbour transactions. We show that our implementation is computationally sound: that is, adversaries can make tokens diverge from their ideal functionality only with negligible probability.}
}


@inproceedings{DBLP:conf/csfw/0044NBP21,
	author = {Yu Wang and
                  Siddhartha Nalluri and
                  Borzoo Bonakdarpour and
                  Miroslav Pajic},
	title = {Statistical Model Checking for Hyperproperties},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00009},
	doi = {10.1109/CSF51468.2021.00009},
	timestamp = {Tue, 07 May 2024 20:11:42 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/0044NBP21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Hyperproperties have shown to be a powerful tool for expressing and reasoning about information-flow security policies. In this paper, we investigate the problem of statistical model checking (SMC) for hyperproperties. Unlike exhaustive model checking, SMC works based on drawing samples from the system at hand and evaluate the specification with statistical confidence. The main benefit of applying SMC over exhaustive techniques is its efficiency and scalability. To reason about probabilistic hyperproperties, we first propose the temporal logic HyperPCTL* that extends PCTL* and HyperPCTL. We show that HyperPCTL* can express important probabilistic information-flow security policies that cannot be expressed with HyperPCTL. Then, we introduce SMC algorithms for verifying HyperPCTL* formulas on discrete-time Markov chains, based on sequential probability ratio tests (SPRT) with a new notion of multidimensional indifference region. Our SMC algorithms can handle both non-nested and nested probability operators for any desired significance level. To show the effectiveness of our technique, we evaluate our SMC algorithms on four case studies focused on information security: timing side-channel vulnerability in encryption, probabilistic anonymity in dining cryptographers, probabilistic noninterference of parallel programs, and the performance of a randomized cache replacement policy that acts as a countermeasure against cache flush attacks.}
}


@inproceedings{DBLP:conf/csfw/KarantaidouB21,
	author = {Ioanna Karantaidou and
                  Foteini Baldimtsi},
	title = {Efficient Constructions of Pairing Based Accumulators},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00033},
	doi = {10.1109/CSF51468.2021.00033},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/KarantaidouB21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Cryptographic accumulators are a crucial building block for a variety of applications where you need to represent a set of elements in a compact format while still being able to provide proofs of (non)membership. In this work, we give a number of accumulator constructions for the bilinear pairing setting in the trapdoor-based scenario, where a trusted manager maintains the accumulator. Using modular accumulator techniques, we first present the first optimally efficient (in terms of communication cost) dynamic, positive accumulators in the pairing setting. Additionally, we present a novel modular approach to construct universal accumulators that avoid costly non-membership proofs. We instantiate our generic construction and present the first universal accumulator in the bilinear pairing setting, that achieves constant parameter size, constant cost for element additions/deletions and witness generation by the manager, constant witness updates by the users and constant (non)membership verification. We finally show how our proposed universal accumulator construction can give rise to efficient ZK accumulators with constant non-membership witness updates.}
}


@inproceedings{DBLP:conf/csfw/BuddeS21,
	author = {Carlos E. Budde and
                  Mari{\"{e}}lle Stoelinga},
	title = {Efficient Algorithms for Quantitative Attack Tree Analysis},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00041},
	doi = {10.1109/CSF51468.2021.00041},
	timestamp = {Thu, 14 Oct 2021 10:13:17 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BuddeS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Numerous analysis methods for quantitative attack tree analysis have been proposed. These algorithms compute relevant security metrics, i.e. performance indicators that quantity how good the security of a system is, such as the most likely attack, the cheapest, or the most damaging one. This paper classifies attack trees in two dimensions: proper trees vs. directed acyclic graphs (i.e. with shared subtrees); and static vs. dynamic gates. For each class, we propose novel algorithms that work over a generic attribute domain, encompassing a large number of concrete security metrics defined on the attack tree semantics. We also analyse the computational complexity of our methods.}
}


@inproceedings{DBLP:conf/csfw/BadertscherKKW21,
	author = {Christian Badertscher and
                  Aggelos Kiayias and
                  Markulf Kohlweiss and
                  Hendrik Waldner},
	title = {Consistency for Functional Encryption},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00045},
	doi = {10.1109/CSF51468.2021.00045},
	timestamp = {Sat, 30 Sep 2023 09:37:58 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BadertscherKKW21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {In functional encryption (FE) a sender, Alice, encrypts plaintexts for which a receiver, Bob, can obtain functional evaluations, while Charlie is responsible for initializing the encryption keys and issuing the decryption keys. Standard notions of security for FE deal with a malicious Bob and guarantee the confidentiality of Alice’s messages despite the leakage that occurs due to the functional keys that are revealed to the adversary via various forms of indistinguishability experiments that correspond to IND-CPA, IND-CCA and simulation-based security.In this work we provide a complete and systematic investigation of Consistency, a natural security property for FE, that deals with attacks that can be mounted by Alice, Charlie or a collusion of the two against Bob. We develop three main types of consistency notions according to which set of parties is corrupted and investigate their relation to the standard security properties of FE. To validate our different consistency types, we extend the universally composable framework for FE by Matt and Maurer (CSF 2015) and we show that our consistency notions naturally complement FE security by proving how they imply (and are implied by) UC security depending on which set of parties is corrupted; in this way we demonstrate a complete characterization of consistency for FE. Finally, we provide explicit constructions that achieve consistency efficiently either directly via a construction based on MDDH for specific function classes of inner products over a modulo group or generically for all the consistency types via compilers using standard cryptographic tools.}
}


@inproceedings{DBLP:conf/csfw/LamportS21,
	author = {Leslie Lamport and
                  Fred B. Schneider},
	title = {Verifying Hyperproperties With {TLA}},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00012},
	doi = {10.1109/CSF51468.2021.00012},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/LamportS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Hyperproperties generalize ordinary properties by expressing relations among multiple executions of a system. Self–composition has been used to reduce verifying that a system satisfies certain classes of Hyperproperties to verifying that a derived system satisfies an ordinary property. By describing systems and their properties in the temporal logic TLA, we use self–composition to handle a larger class of Hyperproperties that includes those we have seen that express security conditions. TLA tools are used to verify that high–level designs of industrial systems satisfy properties. Now, they can also verify that those systems satisfy these Hyperproperties. No prior knowledge of Hyperproperties or TLA is assumed.}
}


@inproceedings{DBLP:conf/csfw/AbuahSDN21,
	author = {Chike Abuah and
                  Alex Silence and
                  David Darais and
                  Joseph P. Near},
	title = {{DDUO:} General-Purpose Dynamic Analysis for Differential Privacy},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00043},
	doi = {10.1109/CSF51468.2021.00043},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/AbuahSDN21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Differential privacy enables general statistical analysis of data with formal guarantees of privacy protection at the individual level. Tools that assist data analysts with utilizing differential privacy have frequently taken the form of programming languages and libraries. However, many existing programming languages designed for compositional verification of differential privacy impose significant burden on the programmer (in the form of complex type annotations). Supplementary library support for privacy analysis built on top of existing general-purpose languages has been more usable, but incapable of pervasive end-to-end enforcement of sensitivity analysis and privacy composition. We introduce DDuo, a dynamic analysis for enforcing differential privacy. DDuo is usable by non-experts: its analysis is automatic and it requires no additional type annotations. DDuo can be implemented as a library for existing programming languages; we present a reference implementation in Python which features moderate runtime overheads on realistic workloads. We include support for several data types, distance metrics and operations which are commonly used in modern machine learning programs. We also provide initial support for tracking the sensitivity of data transformations in popular Python libraries for data analysis. We formalize the novel core of the DDuo system and prove it sound for sensitivity analysis via a logical relation for metric preservation. We also illustrate DDuo's usability and flexibility through various case studies which implement state-of-the-art machine learning algorithms.}
}


@inproceedings{DBLP:conf/csfw/SidorencoOS21,
	author = {Nikolaj Sidorenco and
                  Sabine Oechsner and
                  Bas Spitters},
	title = {Formal security analysis of MPC-in-the-head zero-knowledge protocols},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--14},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00050},
	doi = {10.1109/CSF51468.2021.00050},
	timestamp = {Mon, 03 Jan 2022 22:25:37 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/SidorencoOS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Zero-knowledge proofs allow a prover to convince a verifier of the veracity of a statement without revealing any other information. An interesting class of zero-knowledge protocols are those following the MPC-in-the-head paradigm (Ishai et al., STOC ’07) which use secure multiparty computation (MPC) protocols as the basis. Efficient instances of this paradigm have emerged as an active research topic in the last years, starting with ZKBoo (Giacomelli et al., USENIX ’16). Zero-knowledge protocols are a vital building block in the design of privacy-preserving technologies as well as cryptographic primitives like digital signature schemes that provide post-quantum security. This work investigates the security of zero-knowledge protocols following the MPC-in-the-head paradigm. We provide the first machine-checked security proof of such a protocol on the example of ZKBoo. Our proofs are checked in the EasyCrypt proof assistant. To enable a modular security proof, we develop a new security notion for the MPC protocols used in MPC-in-the-head zero-knowledge protocols. This allows us to recast existing security proofs in a black-box fashion which we believe to be of independent interest.}
}


@inproceedings{DBLP:conf/csfw/Hunt021,
	author = {Sebastian Hunt and
                  David Sands},
	title = {A Quantale of Information},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00031},
	doi = {10.1109/CSF51468.2021.00031},
	timestamp = {Thu, 14 Oct 2021 10:13:17 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/Hunt021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Information flow properties are the semantic cornerstone of a wide range of program transformations, program analyses, and security properties. The variety of information that can be transmitted from inputs to outputs in a deterministic system can be captured by representing information as equivalence relations over the sets of possible values, using an equivalence relation on the input domain to model what may be learned, and an equivalence relation on the output to model what may be observed. The set of equivalence relations over a given set of values form a lattice, where the partial order models containment of information, and lattice join models the effect of combining information. This elegant and general structure is sometimes referred to as the lattice of information.In this paper we identify an abstraction of information flow which has not been studied previously, namely disjunctive dependency (depending on x or y, as distinct from depending on both x and y). We argue that this refines the space of semantic models for dependency in a way which is both interesting in its own right and which has applications in security settings of practical interest (in particular, where so-called “Chinese wall policies” are in effect).To model disjunctive dependency we introduce a nontrivial generalisation of the lattice of information in the form of a richer structure, built on sets of equivalence relations closed under a novel condition called tiling-closure. This structure forms a quantale - a lattice equipped with a tensor operation - in which lattice join corresponds to disjunctive combination of information, and tensor corresponds to conjunctive combination. Using this we generalise the definition of information flow properties, and show that the definition has the key properties needed to support compositional reasoning about programs.}
}


@inproceedings{DBLP:conf/csfw/HirschiSB21,
	author = {Lucca Hirschi and
                  Lara Schmid and
                  David A. Basin},
	title = {Fixing the Achilles Heel of E-Voting: The Bulletin Board},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--17},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00016},
	doi = {10.1109/CSF51468.2021.00016},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/HirschiSB21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {The results of electronic elections should be verifiable so that any cheating is detected. To support this, many protocols employ an electronic bulletin board (BB) for publishing data that can be read by participants and used for verifiability checks. We demonstrate that the BB is itself a security-critical component that has often been treated too casually in previous designs and analyses. In particular, we present novel attacks on the e-voting protocols Belenios, Civitas, and Helios that violate some of their central security claims under realistic system assumptions. These attacks were outside the scope of prior security analyses as their verifiability notions assume an idealized BB.To enable the analysis of protocols under realistic assumptions about the BB, we introduce a new verifiability definition applicable to arbitrary BBs. We identify a requirement, called final-agreement, and formally prove that it is sufficient and, in most cases, necessary to achieve verifiability. We then propose a BB protocol that satisfies final-agreement under weak, realistic trust assumptions and provide a machine-checked proof thereof. Our protocol can replace existing BBs, enabling verifiability under much weaker trust assumptions.}
}


@inproceedings{DBLP:conf/csfw/BasinLMS21,
	author = {David A. Basin and
                  Andreas Lochbihler and
                  Ueli Maurer and
                  S. Reza Sefidgar},
	title = {Abstract Modeling of System Communication in Constructive Cryptography
                  using CryptHOL},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00047},
	doi = {10.1109/CSF51468.2021.00047},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BasinLMS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Proofs in simulation-based frameworks have the greatest rigor when they are machine checked. But the level of details in these proofs surpasses what the formal-methods community can handle with existing tools. Existing formal results consider streamlined versions of simulation-based frameworks to cope with this complexity. Hence, a central question is how to abstract details from composability results and enable their formal verification.In this paper, we focus on the modeling of system communication in composable security statements. Existing formal models consider fixed communication patterns to reduce the complexity of their proofs. However, as we will show, this can affect the reusability of security statements. We propose an abstract approach to modeling system communication in Constructive Cryptography that avoids this problem. Our approach is suitable for mechanized verification and we use CryptHOL, a framework for developing mechanized cryptography proofs, to implement it in the Isabelle/HOL theorem prover. As a case study, we formalize the construction of a secure channel using Diffie-Hellman key exchange and a one-time-pad.}
}


@inproceedings{DBLP:conf/csfw/BoureanuDDG021,
	author = {Ioana Boureanu and
                  Constantin Catalin Dragan and
                  Fran{\c{c}}ois Dupressoir and
                  David G{\'{e}}rault and
                  Pascal Lafourcade},
	title = {Mechanised Models and Proofs for Distance-Bounding},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00049},
	doi = {10.1109/CSF51468.2021.00049},
	timestamp = {Thu, 23 Jun 2022 19:59:04 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BoureanuDDG021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {In relay attacks, a man-in-the-middle adversary impersonates a legitimate party and makes it this party appear to be of an authenticator, when in fact they are not. In order to counteract relay attacks, distance-bounding protocols provide a means for a verifier (e.g., an payment terminal) to estimate his relative distance to a prover (e.g., a bankcard). We propose FlexiDB, a new cryptographic model for distance bounding, parameterised by different types of fine-grained corruptions. FlexiDB allows to consider classical cases but also new, generalised corruption settings. In these settings, we exhibit new attack strategies on existing protocols. Finally, we propose a proof-of-concept mechanisation of FlexiDB in the interactive cryptographic prover EasyCrypt. We use this to exhibit a flavour of man-in-the-middle security on a variant of MasterCard’s contactless-payment protocol.}
}


@inproceedings{DBLP:conf/csfw/AmericoM21,
	author = {Arthur Am{\'{e}}rico and
                  Pasquale Malacaria},
	title = {Concavity, Core-concavity, Quasiconcavity: {A} Generalizing Framework
                  for Entropy Measures},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--14},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00021},
	doi = {10.1109/CSF51468.2021.00021},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/AmericoM21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {We present a new generalising framework for conditional entropies, considering a limit construction over sequences of core-concave entropies, and prove that quasiconcave functions are the set of such limits. This generalising framework subsumes recently proposed frameworks for entropies in quantitative information flow, including entropies whose conditional form reflects the expected leakage and the leakage in the worst-case scenario. Thanks to the properties of the limits it is also shown that several important information theoretical properties can be proven for the generalised entropies satisfying the axioms.}
}


@inproceedings{DBLP:conf/csfw/BlaabjergA21,
	author = {Jeppe Fredsgaard Blaabjerg and
                  Aslan Askarov},
	title = {Towards Language-Based Mitigation of Traffic Analysis Attacks},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00030},
	doi = {10.1109/CSF51468.2021.00030},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BlaabjergA21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Traffic analysis attacks pose a major risk for online security. Distinctive patterns in communication act as fingerprints, enabling adversaries to de-anonymise communicating parties or to infer sensitive information. Despite the attacks being known for decades, practical solution are scarce. Network layer countermeasures have relied on black box padding schemes that require significant overheads in latency and bandwidth to mitigate the attacks, without fundamentally preventing them, and the problem has received little attention in the language-based information flow literature. Language-based methods provide a strong foundation for fundamentally addressing security issues, but previous work has overwhelmingly assumed that interactive programs communicate over secure channels, where messages are undetectable by unprivileged adversaries. This assumption is too strong for online communication where packets can be trivially observed by eavesdropping. In this paper we introduce SELENE, a small language for principled, provably secure communication over channels where packets are publicly observable, and we demonstrate how our program level defence can reduce the latency and bandwidth overheads induced compared with program-agnostic defence mechanisms. We believe that our results constitute a step towards practical, secure online communication.}
}


@inproceedings{DBLP:conf/csfw/StanBEDIOYES21,
	author = {Orly Stan and
                  Ron Bitton and
                  Michal Ezrets and
                  Moran Dadon and
                  Masaki Inokuchi and
                  Yoshinobu Ohta and
                  Tomohiko Yagyu and
                  Yuval Elovici and
                  Asaf Shabtai},
	title = {Heuristic Approach for Countermeasure Selection Using Attack Graphs},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00003},
	doi = {10.1109/CSF51468.2021.00003},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/StanBEDIOYES21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Selecting the optimal set of countermeasures to secure a network is a challenging task, since it involves various considerations and trade-offs, such as prioritizing the risks to mitigate given the mitigation costs. Previously suggested approaches are based on limited and largely manual risk assessment procedures, provide recommendations for a specific event, or don’t consider the organization’s constraints (e.g., limited budget). In this paper, we present an improved attack graph-based risk assessment process and apply heuristic search to select an optimal countermeasure plan for a given network and budget. The risk assessment process represents the risk in the system in such a way that incorporates the quantitative risk factors and relevant countermeasures; this allows us to assess the risk in the system under different countermeasure plans during the search, without the need to regenerate the attack graph. We also provide a detailed description of countermeasure modeling and discuss how the countermeasures can be automatically matched to the security issues discovered in the network.}
}


@inproceedings{DBLP:conf/csfw/HessMBS21,
	author = {Andreas V. Hess and
                  Sebastian M{\"{o}}dersheim and
                  Achim D. Brucker and
                  Anders Schlichtkrull},
	title = {Performing Security Proofs of Stateful Protocols},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00006},
	doi = {10.1109/CSF51468.2021.00006},
	timestamp = {Tue, 21 Mar 2023 21:02:09 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/HessMBS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {In protocol verification we observe a wide spectrum from fully automated methods to interactive theorem proving with proof assistants like Isabelle/HOL. The latter provide overwhelmingly high assurance of the correctness, which automated methods often cannot: due to their complexity, bugs in such automated verification tools are likely and thus the risk of erroneously verifying a flawed protocol is non-negligible. There are a few works that try to combine advantages from both ends of the spectrum: a high degree of automation and assurance. We present here a first step towards achieving this for a more challenging class of protocols, namely those that work with a mutable long-term state. To our knowledge this is the first approach that achieves fully automated verification of stateful protocols in an LCF-style theorem prover. The approach also includes a simple user-friendly transaction-based protocol specification language embedded into Isabelle, and can also leverage a number of existing results such as soundness of a typed model}
}


@inproceedings{DBLP:conf/csfw/WinterCS21,
	author = {Kirsten Winter and
                  Nicholas Coughlin and
                  Graeme Smith},
	title = {Backwards-directed information flow analysis for concurrent programs},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00017},
	doi = {10.1109/CSF51468.2021.00017},
	timestamp = {Sat, 09 Apr 2022 12:41:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/WinterCS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {A number of approaches have been developed for analysing information flow in concurrent programs in a compositional manner, i.e., in terms of one thread at a time. Early approaches modelled the behaviour of a given thread’s environment using simple read and write permissions on variables, or by associating specific behaviour with whether or not locks are held. Recent approaches allow more general representations of environmental behaviour, increasing applicability. This, however, comes at a cost. These approaches analyse the code in a forwards direction, from the start of the program to the end, constructing the program’s entire state after each instruction. This process needs to take into account the environmental influence on all shared variables of the program. When environmental influence is modelled in a general way, this leads to increased complexity, hindering automation of the analysis. In this paper, we present a compositional information flow analysis for concurrent systems which is the first to support a general representation of environmental behaviour and be automated within a theorem prover. Our approach analyses the code in a backwards direction, from the end of the program to the start. Rather than constructing the entire state at each instruction, it generates only the security-related proof obligations. These are, in general, much simpler, referring to only a fraction of the program’s shared variables and thus reducing the complexity introduced by environmental behaviour. For increased applicability, our approach analyses value-dependent information flow, where the security classification of a variable may depend on the current state. The resulting logic has been proved sound within the theorem prover Isabelle/HOL.}
}


@inproceedings{DBLP:conf/csfw/BaumannDGN21,
	author = {Christoph Baumann and
                  Mads Dam and
                  Roberto Guanciale and
                  Hamed Nemati},
	title = {On Compositional Information Flow Aware Refinement},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00010},
	doi = {10.1109/CSF51468.2021.00010},
	timestamp = {Mon, 26 Jun 2023 20:45:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BaumannDGN21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {The concepts of information flow security and refinement are known to have had a troubled relationship ever since the seminal work of McLean. In this work we study refinements that support changes in data representation and semantics, including the addition of state variables that may induce new observational power or side channels. We propose a new epistemic approach to ignorance-preserving refinement where an abstract model is used as a specification of a system’s permitted information flows, that may include the declassification of secret information. The core idea is to require that refinement steps must not induce observer knowledge that is not already available in the abstract model. Our study is set in the context of a class of shared variable multiagent models similar to interpreted systems in epistemic logic. We demonstrate the expressiveness of our framework through a series of small examples and compare our approach to existing, stricter notions of information-flow secure refinement based on bisimulations and noninterference preservation. Interestingly, noninterference preservation is not supported “out of the box” in our setting, because refinement steps may introduce new secrets that are independent of secrets already present at abstract level. To support verification, we first introduce a “cube-shaped” unwinding condition related to conditions recently studied in the context of value-dependent noninterference, kernel verification, and secure compilation. A fundamental problem with ignorance-preserving refinement, caused by the support for general data and observation refinement, is that sequential composability is lost. We propose a solution based on relational pre-and postconditions and illustrate its use together with unwinding on the oblivious RAM construction of Chung and Pass.}
}


@inproceedings{DBLP:conf/csfw/BichhawatM021,
	author = {Abhishek Bichhawat and
                  McKenna McCall and
                  Limin Jia},
	title = {Gradual Security Types and Gradual Guarantees},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00015},
	doi = {10.1109/CSF51468.2021.00015},
	timestamp = {Mon, 26 Jun 2023 20:45:22 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BichhawatM021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Information flow type systems enforce the security property of noninterference by detecting unauthorized data flows at compile-time. However, they require precise type annotations, making them difficult to use in practice as much of the legacy infrastructure is written in untyped or dynamically-typed languages. Gradual typing seamlessly integrates static and dynamic typing, providing the best of both approaches, and has been applied to information flow control, where information flow monitors are derived from gradual security types. Prior work on gradual information flow typing uncovered tensions between noninterference and the dynamic gradual guarantee— the property that less precise security type annotations in a program should not cause more runtime errors.This paper re-examines the connection between gradual information flow types and information flow monitors to identify the root cause of the tension between the gradual guarantees and noninterference. We develop runtime semantics for a simple imperative language with gradual information flow types that provides both noninterference and gradual guarantees. We leverage a proof technique developed for FlowML and reduce noninterference proofs to preservation proofs.}
}


@inproceedings{DBLP:conf/csfw/XiangFC21,
	author = {Jian Xiang and
                  Nathan Fulton and
                  Stephen Chong},
	title = {Relational Analysis of Sensor Attacks on Cyber-Physical Systems},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00035},
	doi = {10.1109/CSF51468.2021.00035},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/XiangFC21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Cyber-physical systems, such as self-driving cars or autonomous aircraft, must defend against attacks that target sensor hardware. Analyzing system design can help engineers understand how a compromised sensor could impact the system’s behavior; however, designing security analyses for cyber-physical systems is difficult due to their combination of discrete dynamics, continuous dynamics, and nondeterminism.This paper contributes a framework for modeling and analyzing sensor attacks on cyber-physical systems, using the formalism of hybrid programs. We formalize and analyze two relational properties of a system’s robustness. These relational properties respectively express (1) whether a system’s safety property can be influenced by sensor attacks, and (2) whether a system’s high-integrity state can be affected by sensor attacks. We characterize these relational properties by defining an equivalence relation between a system under attack and the original unattacked system. That is, the system satisfies the robustness properties if executions of the attacked system are appropriately related to executions of the unattacked system.We present two techniques for reasoning about the equivalence relation and thus proving the relational properties for a system. One proof technique decomposes large proof obligations to smaller proof obligations. The other proof technique adapts the self-composition technique from the literature on secure information-flow, allowing us to reduce reasoning about the equivalence of two systems to reasoning about properties of a single system. This technique allows us to reuse existing tools for reasoning about properties of hybrid programs, but is challenging due to the combination of discrete dynamics, continuous dynamics, and nondeterminism.To validate the usefulness of our relational properties and proof techniques, we present three case studies motivated by real design flaws in existing cyber-physical systems.}
}


@inproceedings{DBLP:conf/csfw/Kunnemann0021,
	author = {Robert K{\"{u}}nnemann and
                  Deepak Garg and
                  Michael Backes},
	title = {Accountability in the Decentralised-Adversary Setting},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00007},
	doi = {10.1109/CSF51468.2021.00007},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/Kunnemann0021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {A promising paradigm in protocol design is to hold parties accountable for misbehavior, instead of postulating that they are trustworthy. Recent approaches in defining this property, called accountability, characterized malicious behavior as a deviation from the protocol that causes a violation of the desired security property, but did so under the assumption that all deviating parties are controlled by a single, centralized adversary. In this work, we investigate the setting where multiple parties can deviate with or without coordination in a variant of the applied-\nπ\ncalculus.We first demonstrate that, under realistic assumptions, it is impossible to determine all misbehaving parties; however, we show that accountability can be relaxed to exclude causal dependencies that arise from the behavior of deviating parties, and not from the protocol as specified. We map out the design space for the relaxation, point out protocol classes separating these notions and define conditions under which we can guarantee fairness and completeness. Most importantly, we discover under which circumstances it is correct to consider accountability in the single-adversary setting, where this property can be verified with off-the-shelf protocol verification tools.}
}


@inproceedings{DBLP:conf/csfw/FirsovLT21,
	author = {Denis Firsov and
                  Henri Lakk and
                  Ahto Truu},
	title = {Verified Multiple-Time Signature Scheme from One-Time Signatures and
                  Timestamping},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--13},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00051},
	doi = {10.1109/CSF51468.2021.00051},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/FirsovLT21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Buldas, Laanoja, and Truu designed a family of server-assisted digital signature schemes (BLT signatures) built around cryptographic timestamping and forward-resistant tag systems. The original constructions had either expensive key generation phase or stateful client-side computations. In this paper, we construct a stateless tag system with efficient key generation from one-time signature schemes. We prove that the proposed tag system is forward-resistant and when combined with cryptographic timestamping, it induces a secure (existentially unforgeable) multiple-time signature scheme. Our constructions are developed and verified using the EasyCrypt framework.}
}


@inproceedings{DBLP:conf/csfw/DasB0PS21,
	author = {Ankush Das and
                  Stephanie Balzer and
                  Jan Hoffmann and
                  Frank Pfenning and
                  Ishani Santurkar},
	title = {Resource-Aware Session Types for Digital Contracts},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00004},
	doi = {10.1109/CSF51468.2021.00004},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/DasB0PS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Programming digital contracts comes with unique challenges, which include (i) expressing and enforcing protocols of interaction, (ii) controlling resource usage, and (iii) preventing the duplication or deletion of a contract’s assets. This article presents the design and type-theoretic foundation of Nomos, a programming language for digital contracts that addresses these challenges. To express and enforce protocols, Nomos is based on shared binary session types. To control resource usage, Nomos employs automatic amortized resource analysis. To prevent the duplication or deletion of assets, Nomos uses a linear type system. A monad integrates the effectful session-typed language with a general-purpose functional language. Nomos’ prototype implementation features linear-time type checking and efficient type reconstruction that includes automatic inference of resource bounds via off-the-shelf linear optimization. The effectiveness of the language is evaluated with case studies on implementing common smart contracts such as auctions, elections, and currencies. Nomos is completely formalized, including the type system, a cost semantics, and a transactional semantics to deploy Nomos contracts on a blockchain. The type soundness proof ensures that protocols are followed at run-time and that types establish sound upper bounds on the resource consumption, ruling out re-entrancy and out-of-gas vulnerabilities.}
}


@inproceedings{DBLP:conf/csfw/GondronM21,
	author = {S{\'{e}}bastien Gondron and
                  Sebastian M{\"{o}}dersheim},
	title = {Vertical Composition and Sound Payload Abstraction for Stateful Protocols},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00038},
	doi = {10.1109/CSF51468.2021.00038},
	timestamp = {Sat, 09 Apr 2022 12:41:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/GondronM21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {This paper deals with a problem that arises in vertical composition of protocols, i.e., when a channel protocol is used to encrypt and transport arbitrary data from an application protocol that uses the channel. Our work proves that we can verify that the channel protocol ensures its security goals independent of a particular application. More in detail, we build a general paradigm to express vertical composition of an application protocol and a channel protocol, and we give a transformation of the channel protocol where the application payload messages are replaced by abstract constants in a particular way that is feasible for standard automated verification tools. We prove that this transformation is sound for a large class of channel and application protocols. The requirements that channel and application have to satisfy for the vertical composition are all of an easy-to-check syntactic nature.}
}


@inproceedings{DBLP:conf/csfw/OakABS21,
	author = {Aditya Oak and
                  Amir M. Ahmadian and
                  Musard Balliu and
                  Guido Salvaneschi},
	title = {Language Support for Secure Software Development with Enclaves},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00037},
	doi = {10.1109/CSF51468.2021.00037},
	timestamp = {Mon, 26 Jun 2023 20:45:21 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/OakABS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Confidential computing is a promising technology for securing code and data-in-use on untrusted host machines, e.g., the cloud. Many hardware vendors offer different implementations of Trusted Execution Environments (TEEs). A TEE is a hardware protected execution environment that allows performing confidential computations over sensitive data on untrusted hosts. Despite the appeal of achieving strong security guarantees against low-level attackers, two challenges hinder the adoption of TEEs. First, developing software in high-level managed languages, e.g., Java or Scala, taking advantage of existing TEEs is complex and error-prone. Second, partitioning an application into components that run inside and outside a TEE may break application-level security policies, resulting in an insecure application when facing a realistic attacker. In this work, we study both these challenges. We present J E , a programming model that seamlessly integrates a TEE, abstracting away low-level programming details such as initialization and loading of data into the TEE. J E only requires developers to add annotations to their programs to enable the execution within the TEE. Drawing on information flow control, we develop a security type system that checks confidentiality and integrity policies against realistic attackers with full control over the code running outside the TEE. We formalize the security type system for the J E core and prove it sound for a semantic characterization of security. We implement J E and the security type system, enable Java programs to run on Intel SGX with strong security guarantees. We evaluate our approach on use cases from the literature, including a battleship game, a secure event processing system, and a popular processing framework for big data, showing that we correctly handle complex cases of partitioning, information flow, declassification, and trust.}
}


@inproceedings{DBLP:conf/csfw/SchwabeVWW21,
	author = {Peter Schwabe and
                  Beno{\^{\i}}t Viguier and
                  Timmy Weerwag and
                  Freek Wiedijk},
	title = {A Coq proof of the correctness of {X25519} in TweetNaCl},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00023},
	doi = {10.1109/CSF51468.2021.00023},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/SchwabeVWW21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {We formally prove that the C implementation of the X25519 key-exchange protocol in the TweetNaCl library is correct. We prove both that it correctly implements the protocol from Bernstein’s 2006 paper, as standardized in RFC 7748, as well as the absence of undefined behavior like arithmetic overflows and array out-of-bounds errors. We also formally prove, based on the work of Bartzia and Strub, that X25519 is mathematically correct, i.e., that it correctly computes scalar multiplication on the elliptic curve Curve25519. The proofs are all computer-verified using the Coq theorem prover. To establish the link between C and Coq we use the Verified Software Toolchain (VST).}
}


@inproceedings{DBLP:conf/csfw/DaxK21,
	author = {Alexander Dax and
                  Robert K{\"{u}}nnemann},
	title = {On the Soundness of Infrastructure Adversaries},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00039},
	doi = {10.1109/CSF51468.2021.00039},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/DaxK21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Campus Companies and network operators perform risk assessment to inform policy-making, guide infrastructure investments or to comply with security standards such as ISO 27001. Due to the size and complexity of these networks, risk assessment techniques such as attack graphs or trees describe the attacker with a finite set of rules. This characterization of the attacker can easily miss attack vectors or overstate them, potentially leading to incorrect risk estimation. In this work, we propose the first methodology to justify a rule-based attacker model. Conceptually, we add another layer of abstraction on top of the symbolic model of cryptography, which reasons about protocols and abstracts cryptographic primitives. This new layer reasons about Internet-scale networks and abstracts protocols.We show, in general, how the soundness and completeness of a rule-based model can be ensured by verifying trace properties, linking soundness to safety properties and completeness to liveness properties. We then demonstrate the approach for a recently proposed threat model that quantifies the confidentiality of email communication on the Internet, including DNS, DNSSEC, and SMTP. Using off-the-shelf protocol verification tools, we discover two flaws in their threat model. After fixing them, we show that it provides symbolic soundness.}
}


@inproceedings{DBLP:conf/csfw/BichhawatFY21,
	author = {Abhishek Bichhawat and
                  Matt Fredrikson and
                  Jean Yang},
	title = {Automating Audit with Policy Inference},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00001},
	doi = {10.1109/CSF51468.2021.00001},
	timestamp = {Sun, 20 Aug 2023 17:39:02 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BichhawatFY21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {The risk posed by high-profile data breaches has raised the stakes for adhering to data access policies for many organizations, but the complexity of both the policies themselves and the applications that must obey them raises significant challenges. To mitigate this risk, fine-grained audit of access to private data has become common practice, but this is a costly, time-consuming, and error-prone process.We propose an approach for automating much of the work required for fine-grained audit of private data access. Starting from the assumption that the auditor does not have an explicit, formal description of the correct policy, but is able to decide whether a given policy fragment is partially correct, our approach gradually infers a policy from audit log entries. When the auditor determines that a proposed policy fragment is appropriate, it is added to the system’s mechanized policy, and future log entries to which the fragment applies can be dealt with automatically. We prove that for a general class of attribute-based data policies, this inference process satisfies a monotonicity property which implies that eventually, the mechanized policy will comprise the full set of access rules, and no further manual audit is necessary. Finally, we evaluate this approach using a case study involving synthetic electronic medical records and the HIPAA rule, and show that the inferred mechanized policy quickly converges to the full, stable rule, significantly reducing the amount of effort needed to ensure compliance in a practical setting.}
}


@inproceedings{DBLP:conf/csfw/CamenischDR21,
	author = {Jan Camenisch and
                  Maria Dubovitskaya and
                  Alfredo Rial},
	title = {Concise {UC} Zero-Knowledge Proofs for Oblivious Updatable Databases},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00008},
	doi = {10.1109/CSF51468.2021.00008},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/CamenischDR21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {We propose an ideal functionality\nF\nCD\nand a construction\nΠ\nCD\nfor oblivious and updatable committed databases.\nF\nCD\nallows a prover\nP\nto read, write, and update values in a database and to prove to a verifier\nV\nin zero-knowledge (ZK) that a value is read from or written into a certain position. The following properties must hold: (1) values stored in the database remain hidden from\nV\n; (2) a value read from a certain position is equal to the value previously written into that position; (3) (obliviousness) both the value read or written and its position remain hidden from\nV\n.\nΠ\nCD\nis based on vector commitments. After the initialization phase, the cost of read and write operations is independent of the database size, outperforming other techniques that achieve cost sublinear in the dataset size for prover and/or verifier. Therefore, our construction is especially appealing for large datasets. In existing “commit-and-prove” two-party protocols, the task of maintaining a committed database between\nP\nand\nV\nand reading and writing values into it is not separated from the task of proving statements about the values read or written.\nF\nCD\nallows us to improve modularity in protocol design by separating those tasks. In comparison to simply using a commitment scheme to maintain a committed database,\nF\nCD\nallows\nP\nto hide efficiently the positions read or written from\nV\n. Thanks to this property, we design protocols for e.g. privacy-preserving e-commerce and location-based services where\nV\ngathers aggregate statistics about the statements that\nP\nproves in ZK.}
}


@inproceedings{DBLP:conf/csfw/MorioK21,
	author = {Kevin Morio and
                  Robert K{\"{u}}nnemann},
	title = {Verifying Accountability for Unbounded Sets of Participants},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00032},
	doi = {10.1109/CSF51468.2021.00032},
	timestamp = {Sun, 02 Oct 2022 15:58:14 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/MorioK21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Little can be achieved in the design of security protocols without trusting at least some participants. This trust should be justified or, at the very least, subject to examination. One way to strengthen trustworthiness is to hold parties accountable for their actions, as this provides a strong incentive to refrain from malicious behavior. This has led to an increased interest in accountability in the design of security protocols.In this work, we combine the accountability definition of Künnemann, Esiyok, and Backes [21] with the notion of case tests to extend its applicability to protocols with unbounded sets of participants. We propose a general construction of verdict functions and a set of verification conditions that achieve soundness and completeness.Expressing the verification conditions in terms of trace properties allows us to extend TAMARIN—a protocol verification tool— with the ability to analyze and verify accountability properties in a highly automated way. In contrast to prior work, our approach is significantly more flexible and applicable to a wider range of protocols.}
}


@inproceedings{DBLP:conf/csfw/JuradoP021,
	author = {Mireya Jurado and
                  Catuscia Palamidessi and
                  Geoffrey Smith},
	title = {A Formal Information-Theoretic Leakage Analysis of Order-Revealing
                  Encryption},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00046},
	doi = {10.1109/CSF51468.2021.00046},
	timestamp = {Sun, 02 Oct 2022 15:58:14 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/JuradoP021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Order-Revealing Encryption (ORE) allows deriving the order of two plaintexts to facilitate database functions such as range queries and sorting. Ideally, nothing is observable to an adversary beyond the order of the messages. Unfortunately, Ideal ORE is challenging to implement, and a variation of it has then been developed. This variation, referred to as CLWW ORE, reveals the first differing bit position between every two plaintexts, in addition to the order.We provide a formal leakage analysis of these two ORE variations by applying the information-theoretic quantitative information flow (QIF) framework. We evaluate two threat models: (1) the Bayes scenario in which an adversary wishes to guess the secret entirely and (2) a bucketing scenario in which an adversary is content to simply guess the range of the plaintext. We provide security implications, usage guidelines, and a mitigation technique that improves the security of Ideal ORE. We find that while Ideal and CLWW ORE perform similarly under the Bayes scenario, CLWW ORE is fundamentally insecure under the bucketing scenario.}
}


@inproceedings{DBLP:conf/csfw/MiyaharaKMS21,
	author = {Daiki Miyahara and
                  Yuichi Komano and
                  Takaaki Mizuki and
                  Hideaki Sone},
	title = {Cooking Cryptographers: Secure Multiparty Computation Based on Balls
                  and Bags},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00034},
	doi = {10.1109/CSF51468.2021.00034},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/MiyaharaKMS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Imagine two cryptographers wishing to securely compute the AND value of their secret input bits. They are in the kitchen, where all they have are three saucepans with Borscht soup and some kinds of ingredients. Interestingly, by secretly putting ingredients in the saucepans depending on their inputs, they can find only the AND value from the taste of the cooked Borscht. Because cooking for secure computations is not so convenient, let us regard ingredients and saucepans (with Borscht soup) as balls and bags, respectively, which are easy to handle and also familiar tools for learning Probability in high school. Then, our problem is generalized as: Can we realize secure multiparty computations (MPCs) with balls and bags?There are techniques to realize MPCs with everyday objects, such as physical cards, coins, and a PEZ dispenser. We encode the input bits with such objects and securely compute some predetermined function using them. In this paper, we present a novel technique based on the physical properties of balls and bags. That is, our challenges are how to utilize an interesting feature that the balls become disordered immediately after they are put into a bag, namely they are “automatically shuffled”. We give the first framework of MPCs using balls and bags (namely, ball-based cryptography), and propose secure AND computation and general MPCs. Our protocols are realizations of usable security which helps people with understanding the principles of MPCs as well as solving social problems in daily life.}
}


@inproceedings{DBLP:conf/csfw/BalogluBM021,
	author = {Sevdenur Baloglu and
                  Sergiu Bursuc and
                  Sjouke Mauw and
                  Jun Pang},
	title = {Election Verifiability Revisited: Automated Security Proofs and Attacks
                  on Helios and Belenios},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00019},
	doi = {10.1109/CSF51468.2021.00019},
	timestamp = {Sat, 09 Apr 2022 12:41:22 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BalogluBM021.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Election verifiability aims to ensure that the outcome produced by electronic voting systems correctly reflects the intentions of eligible voters, even in the presence of an adversary that may corrupt various parts of the voting infrastructure. Protecting such systems from manipulation is challenging because of their distributed nature involving voters, election authorities, voting servers and voting platforms. An adversary corrupting any of these can make changes that, individually, would go unnoticed, yet in the end will affect the outcome of the election. It is, therefore, important to rigorously evaluate whether the measures prescribed by election verifiability achieve their goals. We propose a formal framework that allows such an evaluation in a systematic and automated way. We demonstrate its application to the verification of various scenarios in Helios and Belenios, two prominent internet voting systems, for which we capture features and corruption models previously outside the scope of formal verification. Relying on the Tamarin protocol prover for automation, we derive new security proofs and attacks on deployed versions of these protocols, illustrating trade-offs between usability and security.}
}


@inproceedings{DBLP:conf/csfw/ThomsenS21,
	author = {S{\o}ren Eller Thomsen and
                  Bas Spitters},
	title = {Formalizing Nakamoto-Style Proof of Stake},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00042},
	doi = {10.1109/CSF51468.2021.00042},
	timestamp = {Mon, 03 Jan 2022 22:25:37 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/ThomsenS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Fault-tolerant distributed systems move the trust in a single party to a majority of parties participating in the protocol. This makes blockchain based crypto-currencies possible: they allow parties to agree on a total order of transactions without a trusted third party. To trust a distributed system, the security of the protocol and the correctness of the implementation must be indisputable. We present the first machine checked proof that guarantees both safety and liveness for a consensus algorithm. We verify a Proof of Stake (PoS) Nakamoto-style blockchain (NSB) protocol, using the foundational proof assistant Coq. In particular, we consider a PoS NSB in a synchronous network with a static set of corrupted parties. We define execution semantics for this setting and prove chain growth, chain quality, and common prefix which together imply both safety and liveness.}
}


@inproceedings{DBLP:conf/csfw/AbateHRMWHMS21,
	author = {Carmine Abate and
                  Philipp G. Haselwarter and
                  Exequiel Rivas and
                  Antoine Van Muylder and
                  Th{\'{e}}o Winterhalter and
                  Catalin Hritcu and
                  Kenji Maillard and
                  Bas Spitters},
	title = {SSProve: {A} Foundational Framework for Modular Cryptographic Proofs
                  in Coq},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--15},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00048},
	doi = {10.1109/CSF51468.2021.00048},
	timestamp = {Tue, 21 Mar 2023 21:02:09 +0100},
	biburl = {https://dblp.org/rec/conf/csfw/AbateHRMWHMS21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {State-separating proofs (SSP) is a recent methodology for structuring game-based cryptographic proofs in a modular way. While very promising, this methodology was previously not fully formalized and came with little tool support. We address this by introducing SSProve, the first general verification framework for machine-checked state-separating proofs. SSProve combines high-level modular proofs about composed protocols, as proposed in SSP, with a probabilistic relational program logic for formalizing the lower-level details, which together enable constructing fully machine-checked crypto proofs in the Coq proof assistant. Moreover, SSProve is itself formalized in Coq, including the algebraic laws of SSP, the soundness of the program logic, and the connection between these two verification styles.}
}


@inproceedings{DBLP:conf/csfw/AlgehedBH21,
	author = {Maximilian Algehed and
                  Jean{-}Philippe Bernardy and
                  Catalin Hritcu},
	title = {Dynamic {IFC} Theorems for Free!},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--14},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00005},
	doi = {10.1109/CSF51468.2021.00005},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/AlgehedBH21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {We show that noninterference and transparency, the key soundness theorems for dynamic IFC libraries, can be obtained “for free”, as direct consequences of the more general parametricity theorem of type abstraction. This allows us to give very short soundness proofs for dynamic IFC libraries such as faceted values and LIO. Our proofs stay short even when fully mechanized for Agda implementations of the libraries in terms of type abstraction.}
}


@inproceedings{DBLP:conf/csfw/Klenze0B21,
	author = {Tobias Klenze and
                  Christoph Sprenger and
                  David A. Basin},
	title = {Formal Verification of Secure Forwarding Protocols},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--16},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00018},
	doi = {10.1109/CSF51468.2021.00018},
	timestamp = {Fri, 13 Aug 2021 09:35:20 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/Klenze0B21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Today’s Internet is built on decades-old networking protocols that lack scalability, reliability, and security. In response, the networking community has developed path-aware Internet architectures that solve these issues while simultaneously empowering end hosts. In these architectures, autonomous systems construct authenticated forwarding paths based on their routing policies. Each end host then selects one of these authorized paths and includes it in the packet header, thus allowing routers to efficiently determine how to forward the packet. A central security property of these architectures is path authorization, requiring that packets can only travel along authorized paths. This property protects the routing policies of autonomous systems from malicious senders.The fundamental role of packet forwarding in the Internet and the complexity of the authentication mechanisms employed call for a formal analysis. In this vein, we develop in Isabelle/HOL a parameterized verification framework for path-aware data plane protocols. We first formulate an abstract model without an attacker for which we prove path authorization. We then refine this model by introducing an attacker and by protecting authorized paths using (generic) cryptographic validation fields. This model is parameterized by the protocol’s authentication mechanism and assumes five simple verification conditions that are sufficient to prove the refinement of the abstract model. We validate our framework by instantiating it with several concrete protocols from the literature and proving that they each satisfy the verification conditions and hence path authorization. No invariants must be proven for the instantiation. Our framework thus supports low-effort security proofs for data plane protocols. The results hold for arbitrary network topologies and sets of authorized paths, a guarantee that state-of-the-art automated security protocol verifiers cannot currently provide.}
}


@inproceedings{DBLP:conf/csfw/BartheBHP21,
	author = {Gilles Barthe and
                  Sandrine Blazy and
                  R{\'{e}}mi Hutin and
                  David Pichardie},
	title = {Secure Compilation of Constant-Resource Programs},
	booktitle = {34th {IEEE} Computer Security Foundations Symposium, {CSF} 2021, Dubrovnik,
                  Croatia, June 21-25, 2021},
	pages = {1--12},
	publisher = {{IEEE}},
	year = {2021},
	url = {https://doi.org/10.1109/CSF51468.2021.00020},
	doi = {10.1109/CSF51468.2021.00020},
	timestamp = {Thu, 14 Oct 2021 10:13:18 +0200},
	biburl = {https://dblp.org/rec/conf/csfw/BartheBHP21.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org},
	abstract = {Observational non-interference (ONI) is a generic information-flow policy for side-channel leakage. Informally, a program is ONI-secure if observing program leakage during execution does not reveal any information about secrets. Formally, ONI is parametrized by a leakage function $\\ell$, and different instances of ONI can be recovered through different instantiations of $\\ell$. One popular instance of ONI is the cryptographic constant-time (CCT) policy, which is widely used in cryptographic libraries to protect against timing and cache attacks. Informally, a program is CCT-secure if it does not branch on secrets and does not perform secret-dependent memory accesses. Another instance of ONI is the constant-resource (CR) policy, a relaxation of the CCT policy which is used in Amazon's s2n implementation of TLS and in several other security applications. Informally, a program is CR-secure if its cost (modelled by a tick operator over an arbitrary semi-group) does not depend on secrets.In this paper, we consider the problem of preserving ONI by compilation. Prior work on the preservation of the CCT policy develops proof techniques for showing that main compiler optimisations preserve the CCT policy. However, these proof techniques critically rely on the fact that the semi-group used for modelling leakage satisfies the property:\\begin{equation*}\\ell_{1}+\\ \\ell_{1}^{\\prime}\\ =\\ell_{2}+\\ell_{2}^{\\prime}\\Rightarrow\\ell_{1}=\\ell_{2}\\wedge\\ \\ell_{1}^{\\prime}\\ =\\ell_{2}^{\\prime}\\end{equation*}Unfortunately, this non-cancelling property fails for the CR policy, because its underlying semi-group is $(\\mathbb{N},\\ +)$ and it is currently not known how to extend existing techniques to policies that do not satisfy non-cancellation.We propose a methodology for proving the preservation of the CR policy during a program transformation. We present an implementation of some elementary compiler passes, and apply the methodology to prove the preservation of these passes. Our results have been mechanically verified using the Coq proof assistant.}
}
